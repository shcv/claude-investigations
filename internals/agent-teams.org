#+TITLE: Agent Teams Internals
#+DATE: 2026-02-13

* Feature Gating

Two-layer gate at line 114895 of =pretty-v2.1.42.js=:

#+begin_src javascript
function l8() {
  if (!$6(process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS)) return false;
  if (!D8("tengu_amber_flint", true)) return false;  // server-side flag
  return true;
}
#+end_src

- =$6()= checks for truthy env var (=CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1=)
- =D8("tengu_amber_flint", true)= checks the server-side feature flag with a default of =true=
- All team tools (TeamCreate, TeamDelete, SendMessage) call =l8()= in their =isEnabled()= method
- Task tools have their own gate: =GH()= checks =CLAUDE_CODE_ENABLE_TASKS= env var

When teammates are spawned, the parent process explicitly sets the env var:

#+begin_src javascript
`cd ${cwd} && env CLAUDECODE=1 CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 ${binary} ${args}`
#+end_src

This ensures teammates always have team features enabled.

* Directory Layout

#+begin_example
~/.claude/
├── teams/
│   └── {team-name}/           # sanitized: [a-z0-9-]
│       ├── config.json        # team roster and metadata
│       └── inboxes/
│           ├── team-lead.json # mailbox: JSON array of messages
│           └── {name}.json    # one per teammate
└── tasks/
    └── {team-name}/
        ├── .lock              # exclusive lock file
        ├── .counter           # next task ID counter
        ├── 1.json             # individual task records
        └── 2.json
#+end_example

* Team Config Schema

=config.json= written by =iFY()= at line 429907:

#+begin_src javascript
{
  name: "team-name",
  description: "purpose",
  createdAt: 1707868800000,
  leadAgentId: "team-lead-{hash}@{team}",
  leadSessionId: "uuid",
  members: [{
    agentId: "agent-id",
    name: "team-lead",              // display name, used for messaging
    agentType: "researcher",
    model: "claude-sonnet-4-5-20250929",
    prompt: "original prompt text",  // only for teammates
    color: "#ff0000",
    planModeRequired: false,
    joinedAt: 1707868800000,
    tmuxPaneId: "%42" | "in-process",
    cwd: "/path/to/workspace",
    subscriptions: [],
    backendType: "tmux" | "iterm2" | "in-process"
  }],
  teamAllowedPaths: [{             // optional: shared permission rules
    toolName: "Write",
    path: "/some/path"
  }]
}
#+end_src

Agent IDs are generated by =WE(name, teamName)= which produces:
="{sanitized-name}@{sanitized-team}"=

* Communication System

** Mailbox Architecture

Messages are stored as JSON arrays in per-agent inbox files.

Write path (=a5()= at line 390264):

#+begin_src javascript
function a5(recipient, message, teamName) {
  BRY(teamName);                    // ensure inboxes/ dir exists
  let inboxPath = pt(recipient, teamName);  // ~/.claude/teams/{team}/inboxes/{name}.json
  let lockPath = `${inboxPath}.lock`;

  lock = dg1.lockSync(inboxPath, { lockfilePath: lockPath });
  let messages = readExisting(recipient, teamName);
  messages.push({ ...message, read: false });
  writeFileSync(inboxPath, JSON.stringify(messages, null, 2));
}
#+end_src

Key properties:
- *File-level locking* via =proper-lockfile= (=lockSync=)
- Messages are plain JSON objects: ={from, text, timestamp, color, summary, read}=
- No message IDs at the mailbox level -- ordering is by array index
- =read= flag used to track delivery status

Read path (=wc()= at line 390238): reads full JSON, returns array.
=K91()= filters to unread only.

** Message Delivery

Two separate polling loops handle delivery:

*** InboxPoller (React component, line 566881)

For the *team lead* (and teammates in certain flows). A React =useInterval= hook:

#+begin_src javascript
cZz = 1000;  // 1-second polling interval
FX(callback, enabled ? cZz : null);
#+end_src

The callback:
1. Reads unread messages from own mailbox
2. Classifies each message by type (shutdown, permission, plan approval, DM, etc.)
3. Routes protocol messages (permission requests, plan approvals) to appropriate handlers
4. Collects regular DMs and idle notifications
5. When session is idle, formats messages into =<teammate-message>= XML tags and submits
   them as a new user turn

Message injection format:

#+begin_src xml
<teammate-message teammate_id="researcher" color="#ff0000" summary="Found the bug">
The issue is in auth.ts line 42...
</teammate-message>
#+end_src

Multiple messages are concatenated with double newlines.

*** In-Process Poll Loop (=YCY()= at line 396722)

For *in-process teammates*. A tight polling loop:

#+begin_src javascript
while (!abortController.signal.aborted) {
  // 1. Check pendingUserMessages first (from UI/leader)
  // 2. Wait 500ms (except first iteration)
  // 3. Check mailbox for shutdown requests (priority)
  // 4. Check mailbox for messages from team-lead (next priority)
  // 5. Check mailbox for messages from anyone else
  // 6. Check task list for assigned tasks
}
#+end_src

Priority order:
1. Pending user messages (injected directly via AppState)
2. Shutdown requests (always handled first)
3. Messages from =team-lead= (prioritized over peer messages)
4. Any unread message from any sender
5. Task list notifications

* Teammate Spawning

Three backend paths determined by =ot()= at line 398314:

** Backend Detection Priority

1. *Already inside tmux* -> use tmux (native, =needsIt2Setup: false=)
2. *In iTerm2 with it2 CLI* -> use iTerm2 (native)
3. *In iTerm2 without it2* -> use tmux (fallback, =needsIt2Setup: true=)
4. *Has tmux available* -> use tmux (external session)
5. *None available* -> error with install instructions

** Spawn: iTerm2 / tmux Split Pane (=SCY()= at line 399103)

- Creates a new tmux split pane or iTerm2 pane
- Runs =claude= CLI in the pane with agent flags
- CLI arguments:

#+begin_src
--agent-id {id}
--agent-name {name}
--team-name {team}
--agent-color {color}
--parent-session-id {session}
--plan-mode-required          # if applicable
--agent-type {type}           # if custom agent
--model {model}               # if override
#+end_src

** Spawn: tmux Window (=hCY()= at line 399238)

- Creates a new tmux *window* (not pane) in a separate tmux session
- Same CLI arguments as split pane
- =backendType: "tmux"= in config

** Spawn: In-Process (=ICY()= at line 399410)

- Runs teammate as a task within the same Node.js process
- No tmux/terminal needed
- Creates AbortController for lifecycle management
- Uses =lW1()= to create in-process context
- =backendType: "in-process"= in config

** Initial Message

After spawning, the lead writes the prompt to the teammate's inbox:

#+begin_src javascript
a5(name, { from: "team-lead", text: prompt, timestamp: now() }, team);
#+end_src

* In-Process Agent Loop

=zCY()= at line 396829 is the main agent loop for in-process teammates:

#+begin_src
while (!aborted && !terminated) {
  1. Build system prompt (base + custom agent instructions + memory)
  2. Check if context needs compaction (token limit)
  3. Run main loop (Wy()) - process messages, call tools
  4. Mark self as idle
  5. Send idle notification to team-lead
  6. Enter poll loop (YCY()) - wait for next message
  7. Process next message type:
     - shutdown_request -> pass to model for graceful handling
     - new_message -> wrap in <teammate-message> and continue
     - aborted -> exit loop
}
#+end_src

** Tool Access

In-process teammates get these tools by default:

#+begin_src javascript
[...customTools, "SendMessage", "TeamCreate", "TeamDelete",
 "TaskCreate", "TaskGet", "TaskList", "TaskUpdate"]
#+end_src

Custom agent definitions can restrict the tool list.

** Context Compaction

When conversation gets too long, the agent loop compacts history:

#+begin_src javascript
if (tokenCount > maxTokens(model)) {
  compactedHistory = fG1(messages, context, ...);
  messages = nt(compactedHistory);
}
#+end_src

* Shutdown Protocol

** Happy Path

1. Lead calls =SendMessage(type: "shutdown_request", recipient: "name")=
2. System generates =requestId=, creates JSON protocol message
3. Message written to teammate's inbox
4. Teammate's poll loop finds shutdown request (prioritized)
5. Message wrapped in =<teammate-message>= and sent to model
6. Model calls =SendMessage(type: "shutdown_response", approve: true)=
7. Response writes approval to lead's inbox
8. For in-process: =abortController.abort()= called (line 430542)
9. For tmux: pane killed via =kill-pane= command (line 399406)
10. Lead removes teammate from roster, marks task completed

** Rejection

Teammate can reject with a reason. Lead receives rejection message.
Teammate continues working.

** Force Kill (on abort)

#+begin_src javascript
abortController.signal.addEventListener("abort", () => {
  let args = insideTmux
    ? ["kill-pane", "-t", paneId]
    : ["-L", socketName, "kill-pane", "-t", paneId];
  exec(tmux, args);
});
#+end_src

* Idle Notification System

When a teammate finishes a turn:

1. Task state updated: =isIdle: true= (line 397046)
2. =Ng4()= called -- writes idle notification to lead's inbox (line 397053)
3. Notification format:

#+begin_src javascript
{
  type: "idle_notification",
  from: "teammate-name",
  timestamp: "ISO8601",
  idleReason: "available" | "interrupted",
  summary: "brief description of last turn",
  completedTaskId: "id",          // optional
  completedStatus: "completed",    // optional
  failureReason: "error message"   // optional
}
#+end_src

4. Lead's InboxPoller picks it up on next 1s tick
5. Delivered to lead as a =<teammate-message>= turn

** TeammateIdle Hook

Also triggers the =TeammateIdle= hook event (line 431672), allowing user-configured
shell commands to run when teammates go idle (e.g., notifications, logging).

Similarly, =TaskCompleted= hook fires when tasks are marked done.

* Permission Routing

Teammates can request permissions from the leader:

1. Teammate encounters a tool that needs permission
2. Permission request written to leader's inbox as protocol message
3. Leader's InboxPoller detects it, creates a =ToolUseConfirmQueue= entry
4. Leader's UI shows the permission prompt with the teammate's badge
5. Leader approves/rejects
6. Response written back to teammate's inbox
7. Teammate's poll loop picks up the response, resolves the permission

This works for:
- Tool permissions (file write, bash execution, etc.)
- Sandbox permissions (network access to specific hosts)

* Plan Approval Flow

1. Teammate spawned with =planModeRequired: true=
2. Teammate works in plan mode (read-only tools)
3. Teammate calls =ExitPlanMode= -> sends plan approval request to inbox
4. Leader's InboxPoller auto-approves (line 567189)
5. Approval includes =permissionMode= for the implementation phase
6. Teammate receives approval, exits plan mode, gains write access

Note: The current implementation *auto-approves* all plans (line 567190:
"auto-approving"). The manual approval via SendMessage is available but
the default flow is automatic.

* Message XML Format

All inter-agent messages are wrapped in XML for injection into conversations:

#+begin_src javascript
function YRA(from, text, color, summary) {
  return `<teammate-message teammate_id="${from}" color="${color}" summary="${summary}">
${text}
</teammate-message>`;
}
#+end_src

This =<teammate-message>= tag is the universal envelope for:
- Regular DMs
- Idle notifications (JSON inside the tag)
- Protocol messages (shutdown requests, permission responses)
- Initial prompts from team lead

* Key Constants

| Constant       | Value  | Purpose                                    |
|----------------+--------+--------------------------------------------|
| =cZz=          | 1000ms | InboxPoller interval (leader/UI side)      |
| =syY=          | 500ms  | In-process poll loop interval (teammates)  |
| =Pz=           | "team-lead" | Default leader name                   |
| =_J=           | "teammate-message" | XML tag name for message wrapping |
| =EN=           | tmux session name | For teammate tmux windows         |

* Name Deduplication

=IRA()= at line 399093 prevents name collisions:

#+begin_src javascript
function IRA(name, teamName) {
  let config = readTeamConfig(teamName);
  let existingNames = new Set(config.members.map(m => m.name.toLowerCase()));
  if (!existingNames.has(name.toLowerCase())) return name;
  let suffix = 2;
  while (existingNames.has(`${name}-${suffix}`.toLowerCase())) suffix++;
  return `${name}-${suffix}`;
}
#+end_src

* Version History

| Version | Change                                               |
|---------+------------------------------------------------------|
| v2.0.59 | Task management introduced                          |
| v2.1.16 | Agent Swarms (TeammateTool, iTerm2 split panes)     |
| v2.1.20 | SendMessageTool replaces old messaging               |
| v2.1.23 | "Swarm" renamed to "team" in UI                     |
| v2.1.31 | Plan eligibility check before team operations        |
| v2.1.33 | TeamCreate/TeamDelete tools, hooks                   |
| v2.1.42 | Current version analyzed                             |
