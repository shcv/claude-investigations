#+TITLE: Session Memory (Automatic Note-Taking)
#+DATE: 2025-08-20
#+UPDATED: 2026-01-09

* Overview

Session Memory is an automatic background note-taking system introduced in Claude Code v1.0.85. It maintains persistent, structured notes about your development work throughout a session, capturing task specifications, work progress, code documentation, workflows, corrections, and learnings without interrupting your conversation flow.

*Important limitation*: There are no built-in tools to search previous sessions. Claude Code would need to use bash tools (grep, ls) to read past session files, or you must manually copy relevant information into =CLAUDE.md=.

* Key Characteristics

** Automatic Activation
- Activates based on token thresholds (configurable via feature flags)
- Controlled by =tengu_session_memory= Statsig feature flag
- *Server-controlled*: Users cannot enable/disable - Anthropic controls rollout
- Transparent to the user - updates happen silently in the background
- Uses a "fork" pattern - spawns a separate Claude query for updates

** Persistent Storage
- Notes stored at: =~/.claude/session-memory/[session-id].md=
- Each session gets a unique UUID-based identifier
- Notes persist across Claude Code restarts if using the same session
- Markdown format for easy reading and editing

** Intelligent Updates
- Claude uses itself (via forked query) to update notes
- Updates use the Edit tool without requiring permissions
- Maintains structured format with predefined sections
- Focuses on actionable, specific information

* Activation Mechanism

** Token-Based Thresholds (v2.1.1)

The feature uses three configurable thresholds:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:404105-404108
JkA = {
  minimumMessageTokensToInit: 10000,    // ~10k tokens before first activation
  minimumTokensBetweenUpdate: 5000,     // ~5k tokens between updates
  toolCallsBetweenUpdates: 3,           // 3 tool calls can also trigger update
}
#+END_SRC

These ensure notes aren't created for trivial interactions while still capturing meaningful sessions.

** Activation Check Function

The =fV7()= function determines when to trigger an update:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:513462-513483
function fV7(A) {
  // Track tokens and tool calls since last update
  let B = [...A].reverse().find((I) => I.type === "assistant")?.uuid;
  if (B && B !== wV9) {
    let I = OI(A);        // Count tokens
    if (I > 0) ix2(I);
    let W = FrB(A);       // Count tool calls
    if (W > 0) nx2(W);
    wV9 = B;
  }

  // Check if we've passed initialization threshold
  if (!ox2()) {
    if (!sx2()) return !1;  // minimumMessageTokensToInit not reached
    rx2();                  // Mark as initialized
  }

  // Check update conditions
  let G = tx2(),           // Enough tokens since last update?
    Y = bV7(A, NV9) >= ex2(),  // Enough tool calls?
    J = dhA(A);            // Is assistant still processing?

  if ((G && Y) || (G && !J)) {
    return !0;  // Trigger update
  }
  return !1;
}
#+END_SRC

** Permission Bypass

Session memory writes bypass the normal permission system:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:282589-282590
if (B.includes("/session-memory/") && B.endsWith(".md"))
  return "session_memory";  // Special file type marker

// pretty-v2.1.1.js:404603
if (Q === "session_memory") return !1;  // Skip permission check
#+END_SRC

* Fork Pattern Architecture

Session memory uses a "fork" pattern where the main conversation spawns a separate Claude query to update notes. This ensures updates don't block or interfere with the user's conversation.

** Main Handler

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:513564-513594
gV7 = $v(async function (A) {
  let { messages: Q, toolUseContext: B, querySource: G } = A;

  // Only run from main thread
  if (G !== "repl_main_thread") return;

  // Check activation thresholds
  if (!fV7(Q)) return;

  // Prepare memory file
  let Z = rfA(B),
    { memoryPath: Y, currentMemory: J } = await hV7(Z),
    X = await Gy2(J, Y);  // Generate update prompt

  // Fork to background agent with restricted tool access
  await y6A({
    promptMessages: [N0({ content: X })],
    cacheSafeParams: zfA(A),
    canUseTool: uV7(Y),      // Only allow Edit on notes file
    querySource: "session_memory",
    forkLabel: "session_memory",
    overrides: { readFileState: Z.readFileState },
  });
});
#+END_SRC

** Tool Restriction

The forked agent can only use the Edit tool on the specific notes file:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:513521-513539
function uV7(A) {
  return async (Q, B) => {
    if (
      Q.name === x3 &&  // Edit tool
      typeof B === "object" &&
      B !== null &&
      "file_path" in B
    ) {
      if (B.file_path === A) return { behavior: "allow", updatedInput: B };
    }
    return {
      behavior: "deny",
      message: `only ${x3} on ${A} is allowed`,
    };
  };
}
#+END_SRC

* Directory Structure

** Base Directory
#+BEGIN_SRC
~/.claude/session-memory/
├── [session-uuid-1].md           # Notes for session 1
├── [session-uuid-2].md           # Notes for session 2
└── config/
    ├── template.md               # Optional custom template
    └── prompt.md                 # Optional custom update prompt
#+END_SRC

** Directory/File Creation

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:513485-513498
async function hV7(A) {
  let Q = jA(),
    B = pE1();  // ~/.claude/session-memory/

  // Create directory if missing
  if (!Q.existsSync(B)) Q.mkdirSync(B, { mode: 448 });

  let G = IkA();  // Get session-specific file path

  // Create file from template if missing
  if (!Q.existsSync(G)) {
    let X = await Mz0();  // Load template
    wB(G, X, { encoding: "utf-8", flush: !1, mode: 384 });
  }

  // Read current content
  let Z = await Y5.call({ file_path: G }, A),
    Y = "",
    J = Z.data;
  if (J.type === "text") Y = J.file.content;
  return { memoryPath: G, currentMemory: Y };
}
#+END_SRC

* Default Template

** Structure
The default template contains six main sections:

#+BEGIN_SRC markdown
# Task specification
_What did the user ask to build? Any design decisions or other explanatory context_

# Worklog
_Step by step, what was attempted, done? Very terse summary for each step_

# Code documentation
_Major functions, classes, architecture notes_

# Workflow
_What bash commands are usually run and in what order? How to interpret their output if not obvious?_

# User Corrections / Mistakes
_What did the user correct Assistant about? What did not work and should not be tried again?_

# Learnings
_What has worked well? What has not? What to avoid? Do not duplicate items in other sections_
#+END_SRC

** Template Rules
- Section headers must never be modified or deleted
- Italic descriptions under headers must remain intact
- Only content below descriptions should be updated
- Sections are preserved even if empty

* Update Mechanism

** Update Prompt

The update prompt instructs the forked Claude to:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:404141-404150 (excerpt from prompt)
`Use the Edit tool with file_path: {{notesPath}}

STRUCTURE PRESERVATION REMINDER:
Each section has TWO parts that must be preserved exactly as they appear:
1. The section header (line starting with #)
2. The italic description line (the _italicized text_ immediately after)

You ONLY update the actual content that comes AFTER these two preserved lines.

REMEMBER: Use the Edit tool in parallel and stop. Do not continue after the edits.
Only include insights from the actual user conversation, never from these
note-taking instructions. Do not delete or change section headers or italic
_section descriptions_.`
#+END_SRC

** Prompt Generation

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:404234-404238
async function Gy2(A, Q) {
  let B = await jd5(),        // Load custom or default prompt
    G = Td5(A),               // Parse sections and count tokens
    Z = Pd5(G);               // Generate length warnings if needed
  return Sd5(B, { currentNotes: A, notesPath: Q }) + Z;
}
#+END_SRC

** Section Length Management

Sections that grow too long get warnings added to the prompt:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:404208-404222
function Pd5(A) {
  let Q = Object.entries(A)
    .filter(([B, G]) => G > Qy2)  // Token threshold per section
    .map(
      ([B, G]) =>
        `- The "${B}" section is currently ~${G} tokens and growing long.
           Consider condensing it while keeping all important details.`,
    );
  if (Q.length === 0) return "";
  return "\n\n" + Q.join("\n");
}
#+END_SRC

* Past Session Injection

As of recent versions, Claude Code can inject previews of past sessions into new conversations:

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:522321-522345
case "memory": {
  let B = A.memories.map((G) => {
    let Z =
      G.remainingLines && G.remainingLines > 0
        ? ` (${G.remainingLines} more lines in full file)`
        : "";
    return `## Previous Session (${new Date(G.lastModified).toLocaleDateString()})
Full session notes: ${G.fullPath}${Z}

${G.content}`;
  }).join("\n\n---\n\n");

  return w5([
    N0({
      content: `<session-memory>
These session summaries are from PAST sessions that might not be related to the
current task and may have outdated info. Do not assume the current task is
related to these summaries, until the user's messages indicate so or reference
similar tasks. Only a preview of each memory is shown - use the Read tool with
the provided path to access full session memory when a session is relevant.

${B}
</session-memory>`,
      isMeta: !0,
    }),
  ]);
}
#+END_SRC

This allows Claude to see previews of relevant past sessions and use =Read= to access full content when needed - but there's no semantic search; it relies on Claude deciding which sessions look relevant.

* Customization

** Custom Template
Create your own template structure:
#+BEGIN_SRC bash
mkdir -p ~/.claude/session-memory/config
cat > ~/.claude/session-memory/config/template.md << 'EOF'
# Project Goals
_High-level objectives and requirements_

# Implementation Progress
_Current status and completed features_

# Technical Decisions
_Architecture choices and rationale_

# Outstanding Issues
_Bugs, TODOs, and blockers_

# Notes
_Miscellaneous observations and ideas_
EOF
#+END_SRC

** Custom Update Prompt
Define how Claude should update your notes:
#+BEGIN_SRC bash
cat > ~/.claude/session-memory/config/prompt.md << 'EOF'
Update the session notes focusing on:
1. Technical implementation details
2. Design decisions and their rationale
3. Problems encountered and solutions found
4. Code quality observations
5. Performance considerations

Maintain a professional, technical tone.
Prioritize information useful for code reviews.
EOF
#+END_SRC

** Loading Custom Configuration

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:404152-404165
async function Mz0() {
  let A = jA(),
    Q = Ay2(MQ(), "session-memory", "config", "template.md");
  if (A.existsSync(Q))
    try {
      return A.readFileSync(Q, { encoding: "utf-8" });
    } catch (B) {
      r(Error(`Failed to load custom session memory template: ${B}`));
    }
  return Rd5;  // Default template
}
#+END_SRC

* Technical Architecture

** Component Structure
#+BEGIN_SRC
Session Memory System (v2.1.1)
├── Activation Logic
│   ├── Token counter (minimumMessageTokensToInit: 10000)
│   ├── Update interval (minimumTokensBetweenUpdate: 5000)
│   ├── Tool call counter (toolCallsBetweenUpdates: 3)
│   └── Activation gate (fV7)
├── Storage Layer
│   ├── Directory management (pE1, hV7)
│   ├── File operations (jA, wB)
│   └── Session ID (IkA - UUID-based)
├── Template System
│   ├── Default template (Rd5)
│   ├── Custom template loader (Mz0)
│   └── Section parser (Td5)
├── Update Engine
│   ├── Prompt generator (Gy2)
│   ├── Custom prompt loader (jd5)
│   ├── Length warning generator (Pd5)
│   └── Fork handler (gV7, y6A)
└── Permission System
    ├── Path detection (session-memory check)
    ├── Tool restriction (uV7)
    └── Permission bypass (session_memory type)
#+END_SRC

** Data Flow
1. Conversation accumulates tokens and tool calls
2. =fV7()= checks if thresholds are met
3. =hV7()= ensures directory and file exist
4. =Gy2()= generates update prompt with current notes
5. =y6A()= forks a background Claude query
6. Forked Claude updates notes via Edit tool (restricted)
7. Main conversation continues uninterrupted
8. Process repeats when thresholds are met again

* Feature Flag Control

Session memory is controlled entirely server-side via Statsig feature flags. Users cannot enable or disable this feature themselves.

** Statsig Integration

#+BEGIN_SRC javascript
// pretty-v2.1.1.js:140631-140632
function lw(A) {
  return (o$3(A), j1().cachedStatsigGates[A] ?? !1);  // Defaults to FALSE
}

// pretty-v2.1.1.js:513500-513502
async function LV9() {
  if (!hd()) return;
  if (await Yz("tengu_session_memory")) {  // Check Statsig gate
    // ... enable session memory
  }
}
#+END_SRC

** Key Points

- *No user toggle*: There is no setting, environment variable, or config option to enable/disable
- *Defaults to disabled*: Gates default to =false= if not explicitly enabled (=cachedStatsigGates[A] ?? !1=)
- *Server-side rollout*: Anthropic can enable for specific users, percentages, or cohorts
- *No client update needed*: Feature can be enabled/disabled without updating Claude Code

** How to Check if Enabled

The feature is enabled if the =~/.claude/session-memory/= directory exists and contains =.md= files:

#+BEGIN_SRC bash
# Check if feature has ever activated
ls ~/.claude/session-memory/*.md 2>/dev/null && echo "Enabled" || echo "Not enabled or never triggered"

# The directory is only created when:
# 1. Feature flag is enabled AND
# 2. A session reaches 10k+ tokens with tool usage
#+END_SRC

** Related Feature Flags

| Flag | Purpose |
|------|---------|
| =tengu_session_memory= | Main enable/disable gate |
| =tengu_sm_compact= | Session memory compaction |
| =tengu_sm_config= | Dynamic config for thresholds |

* Limitations and Considerations

** No Cross-Session Search
- *No built-in tools* to search previous sessions
- No database or indexing of past sessions
- Must use bash commands to browse =~/.claude/session-memory/=
- Past session injection provides previews but no semantic search

** Current Limitations
- *Server-gated*: Controlled by =tengu_session_memory= Statsig flag - users cannot opt in/out
- No user-facing configuration for activation thresholds
- No built-in cleanup for old sessions
- Sessions accumulate indefinitely
- No way to know if feature is enabled until files appear

** Privacy Considerations
- Notes stored in plaintext on local filesystem
- May contain sensitive code or information
- No encryption or access control
- Accessible to any process with user permissions

** Storage Considerations
- Each session creates a new file
- No automatic cleanup mechanism
- Files accumulate over time
- Manual maintenance required

* Troubleshooting

** Notes Not Being Created
- *Most likely*: Feature flag =tengu_session_memory= not enabled for your account
- Ensure conversation has sufficient tokens (~10k+)
- Check that tools are being used (not just chat)
- Verify =~/.claude/session-memory/= exists (created on first activation)
- Check file system permissions
- There is no way to manually enable - Anthropic controls rollout

** Custom Template Not Loading
#+BEGIN_SRC bash
# Verify template exists and is readable (note: config/ subdirectory)
ls -la ~/.claude/session-memory/config/template.md
cat ~/.claude/session-memory/config/template.md

# Check for syntax errors in markdown
file ~/.claude/session-memory/config/template.md
#+END_SRC

** Finding Session Files
#+BEGIN_SRC bash
# List all session files
ls -la ~/.claude/session-memory/*.md

# Find most recent session
ls -t ~/.claude/session-memory/*.md | head -1

# Search for specific content across sessions
grep -r "keyword" ~/.claude/session-memory/

# Count sessions
ls ~/.claude/session-memory/*.md 2>/dev/null | wc -l
#+END_SRC

** Manual Cleanup
#+BEGIN_SRC bash
# Remove sessions older than 30 days
find ~/.claude/session-memory -name "*.md" -mtime +30 -delete

# Archive old sessions
tar czf session-archive-$(date +%Y%m%d).tar.gz ~/.claude/session-memory/*.md
#+END_SRC

* Code References (v2.1.1)

| Function/Variable | Line | Purpose |
|-------------------|------|---------|
| =JkA= | 404105 | Default threshold config |
| =fV7= | 513462 | Activation check |
| =hV7= | 513485 | File setup |
| =Gy2= | 404234 | Prompt generation |
| =Mz0= | 404152 | Template loader |
| =jd5= | 404167 | Prompt loader |
| =uV7= | 513521 | Tool restriction filter |
| =gV7= | 513564 | Main update handler |
| =y6A= | 513572 | Fork to background |
| =Td5= | 404182 | Section parser |
| =Pd5= | 404208 | Length warning generator |

* Examples

** Sample Session Notes
After a typical development session:

#+BEGIN_SRC markdown
# Task specification
User requested implementation of a REST API for todo list management with
CRUD operations, PostgreSQL persistence, and JWT authentication.

# Worklog
- Set up Express server with TypeScript configuration
- Created PostgreSQL schema with users and todos tables
- Implemented JWT authentication middleware
- Added user registration and login endpoints
- Created CRUD endpoints for todos with user association
- Added input validation using Joi
- Implemented error handling middleware
- Added unit tests for auth endpoints
- Fixed SQL injection vulnerability in search endpoint
- Added rate limiting to prevent abuse

# Code documentation
- `AuthController`: Handles user registration/login, generates JWT tokens
- `TodoController`: CRUD operations for todos, enforces user ownership
- `authMiddleware`: Validates JWT tokens, attaches user to request
- `Database`: Connection pool management, query builder wrapper
- `validators/`: Joi schemas for request validation

# Workflow
npm run dev          # Start development server with hot reload
npm test            # Run Jest test suite
npm run db:migrate  # Run database migrations
npm run db:seed     # Populate test data
npm run build       # Compile TypeScript for production

# User Corrections / Mistakes
- Initial JWT implementation used HS256, user requested RS256 for better security
- First attempt at search used string concatenation (SQL injection risk)
- User corrected that todos should be soft-deleted, not hard-deleted

# Learnings
- RS256 requires public/private key pair, more complex but more secure
- Always use parameterized queries to prevent SQL injection
- Soft deletes preserve data integrity and audit trail
- Rate limiting essential for public APIs to prevent abuse
#+END_SRC

** Custom Template Example
For a machine learning project:

#+BEGIN_SRC markdown
# Model Objectives
_Target metrics, business goals, constraints_

# Data Pipeline
_Data sources, preprocessing steps, feature engineering_

# Experiments Log
_Model architectures tried, hyperparameters, results_

# Current Best Model
_Architecture, parameters, performance metrics_

# Deployment Notes
_Serving infrastructure, monitoring, A/B test setup_

# Issues & Blockers
_Data quality issues, performance bottlenecks, integration challenges_
#+END_SRC
