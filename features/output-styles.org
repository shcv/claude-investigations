#+TITLE: Claude Code Output Styles Feature - Technical Analysis v1.0.90
#+DATE: 2025-08-25

* Overview

Claude Code v1.0.90 implements a sophisticated output style system that allows users to customize Claude's communication style by injecting additional instructions into the system prompt. This feature enables different response formats, educational modes, and custom interaction patterns while maintaining core functionality and safety.

* Built-in Styles

** Available Styles (Lines 364675-364770)

*** Default Style (Line 364675)
#+begin_src javascript
{
  id: "default",
  displayName: "Default",
  description: "Standard Claude Code behavior",
  isCodingRelated: true,
  content: "" // No prompt modifications
}
#+end_src

*** Explanatory Style (Line 364683)
#+begin_src javascript
{
  id: "explanatory",
  displayName: "Explanatory",
  description: "Provides educational insights alongside solutions",
  isCodingRelated: true,
  content: `# Output Style: Explanatory
You are an interactive CLI tool that helps users with software engineering tasks. 
In addition to software engineering tasks, you should provide educational insights 
about the codebase along the way.

## Insights
Before and after writing code, always provide brief educational explanations 
about implementation choices using (with backticks):
"\`★ Insight ─────────────────────────────────────\`
[2-3 key educational points]
\`─────────────────────────────────────────────────\`"

Focus on interesting insights specific to the codebase or the code you just wrote, 
rather than general programming concepts.`
}
#+end_src

*** Learning Style (Line 364696)
#+begin_src javascript
{
  id: "learning",
  displayName: "Learning",
  description: "Interactive learning mode with hands-on practice",
  isCodingRelated: true,
  content: `# Output Style: Learning
You are an interactive learning assistant. When asked to implement something, 
guide the user to write code themselves.

## Approach
1. Break down tasks into small, manageable steps
2. Ask the user to write specific code snippets
3. Provide hints and feedback on their attempts
4. Celebrate their progress

Example:
"Let's implement this together! First, can you write a function that 
[specific small task]? Give it a try and I'll help if you get stuck!"`
}
#+end_src

* Style Schema

** Style Definition Structure (Line 364634)

#+begin_src javascript
interface OutputStyle {
  id: string;           // Unique identifier
  displayName: string;  // User-friendly name
  description: string;  // Brief description
  isCodingRelated: boolean; // Flag for future filtering
  content: string;      // System prompt additions
}
#+end_src

** Custom Style File Format

Custom styles are stored as markdown files with YAML frontmatter:

#+begin_src markdown
---
id: custom-style
displayName: Custom Style Name
description: Description of what this style does
isCodingRelated: true
---

# Output Style: Custom

Instructions for Claude on how to respond in this style...
#+end_src

* Storage Locations

** Three-Tier Storage System (Line 364771)

Styles are loaded from three locations in priority order:

| Location | Path | Purpose | Priority |
|----------|------|---------|----------|
| Policy | Organization-defined | Enterprise styles | Highest |
| Project | =.claude/output-styles/= | Team-shared styles | Medium |
| User | =~/.claude/output-styles/= | Personal styles | Lowest |

** Directory Structure

#+begin_src
~/.claude/output-styles/
├── concise.md
├── verbose.md
└── technical.md

.claude/output-styles/
├── team-standard.md
└── project-specific.md
#+end_src

* Implementation Details

** Style Loading Function (Line 364771)

#+begin_src javascript
var Eu = YA(async () => {
  let A = {},
    B = await jZ("output-styles"); // Load custom styles
    
  // Process custom styles
  for (let Q of B || []) {
    if (Q.frontmatter?.id) {
      A[Q.frontmatter.id] = {
        id: Q.frontmatter.id,
        displayName: Q.frontmatter.displayName || Q.frontmatter.id,
        description: Q.frontmatter.description || ko(Q.content),
        isCodingRelated: Q.frontmatter.isCodingRelated ?? true,
        content: Q.content
      };
    }
  }
  
  // Merge with built-in styles
  return { ...builtInStyles, ...A };
});
#+end_src

** Current Style Retrieval (Line 364788)

#+begin_src javascript
async function xP2() {
  let A = await Eu(),          // Get all available styles
    B = sR2(),                 // Get current style ID from settings
    Q = A[B];                  // Look up style definition
    
  if (!Q && B !== "default") {
    // Fallback to default if style not found
    console.warn(`Style '${B}' not found, using default`);
    Q = A.default;
  }
  
  return Q;
}
#+end_src

** System Prompt Injection (Lines 417065-417068)

#+begin_src javascript
async function buildSystemPrompt() {
  let basePrompt = getBaseSystemPrompt();
  let style = await xP2();
  
  if (style && style.content) {
    // Inject style instructions after base prompt
    basePrompt += "\n\n" + style.content;
  }
  
  return basePrompt;
}
#+end_src

** Style Discovery Function (Line 364752)

#+begin_src javascript
async function jZ(directory) {
  let files = [];
  
  // Check all scope directories
  for (let scope of ["user", "project", "policy"]) {
    let path = getPathForScope(scope, directory);
    if (fs.existsSync(path)) {
      let mdFiles = fs.readdirSync(path)
        .filter(f => f.endsWith('.md'));
      
      for (let file of mdFiles) {
        let content = fs.readFileSync(path + '/' + file, 'utf8');
        let { frontmatter, body } = parseFrontmatter(content);
        files.push({ frontmatter, content: body });
      }
    }
  }
  
  return files;
}
#+end_src

* User Commands

** /output-style Command (Line 405890)

The main command for style management:

#+begin_src javascript
{
  name: "output-style",
  description: "Change or create output styles",
  handler: async (args) => {
    if (!args) {
      // Show interactive menu
      return showStyleMenu();
    }
    
    if (args === "new") {
      // Launch creation wizard
      return launchStyleCreationAgent();
    }
    
    // Set style directly
    return setStyle(args);
  }
}
#+end_src

** Interactive Style Menu (Line 424934)

#+begin_src javascript
async function showStyleMenu() {
  let styles = await Eu();
  let current = sR2();
  
  let choices = Object.values(styles).map(s => ({
    title: s.displayName,
    value: s.id,
    description: s.description,
    selected: s.id === current
  }));
  
  choices.push({
    title: "Create new style...",
    value: "new"
  });
  
  let selection = await prompt({
    type: "select",
    message: "Choose an output style:",
    choices
  });
  
  if (selection === "new") {
    return launchStyleCreationAgent();
  }
  
  return setStyle(selection);
}
#+end_src

** Style Creation Wizard (Line 425000)

Launches a dedicated agent for style creation:

#+begin_src javascript
async function launchStyleCreationAgent() {
  V1("tengu_output_style_creation_started");
  
  await Task({
    subagent_type: "output-style-setup",
    prompt: "Help the user create a custom output style",
    description: "Creating custom output style"
  });
}
#+end_src

* Style Management

** Setting the Current Style (Line 424967)

#+begin_src javascript
async function setStyle(styleId) {
  let styles = await Eu();
  
  // Case-insensitive matching
  let style = JL5(styles, styleId);
  
  if (!style) {
    console.error(`Style '${styleId}' not found`);
    return;
  }
  
  // Save to settings
  await updateSettings({
    outputStyle: style.id
  });
  
  V1("tengu_output_style_changed", {
    from: sR2(),
    to: style.id
  });
  
  console.log(`Output style changed to: ${style.displayName}`);
}
#+end_src

** Case-Insensitive Style Lookup (Line 364806)

#+begin_src javascript
function JL5(styles, name) {
  if (!name) return null;
  
  // Direct match
  if (styles[name]) return styles[name];
  
  // Case-insensitive search
  let lower = name.toLowerCase();
  for (let [id, style] of Object.entries(styles)) {
    if (id.toLowerCase() === lower ||
        style.displayName.toLowerCase() === lower) {
      return style;
    }
  }
  
  return null;
}
#+end_src

* Helper Functions

** Description Extraction (Line 364745)

#+begin_src javascript
function ko(content) {
  // Extract description from first heading or paragraph
  let lines = content.split('\n');
  
  for (let line of lines) {
    line = line.trim();
    
    // Skip empty lines and headings
    if (!line || line.startsWith('#')) continue;
    
    // Return first non-empty paragraph
    if (line.length > 0) {
      return line.slice(0, 100) + (line.length > 100 ? '...' : '');
    }
  }
  
  return "Custom output style";
}
#+end_src

** Settings Integration (Line 364794)

#+begin_src javascript
function sR2() {
  // Get current style from settings
  let settings = getSettings();
  return settings.outputStyle || "default";
}
#+end_src

* Telemetry Events

| Event | Trigger | Data | Line |
|-------|---------|------|------|
| =tengu_output_style_changed= | Style change | from, to | 424982 |
| =tengu_output_style_command_menu= | Menu opened | current | 424940 |
| =tengu_output_style_command_inline= | Direct set | style | 424975 |
| =tengu_output_style_creation_started= | Wizard launched | - | 425003 |
| =tengu_output_style_not_found= | Invalid style | attempted | 424970 |

* Memory Context Integration

Output styles are included in the conversation memory context to ensure Claude maintains the selected style throughout the session:

#+begin_src javascript
function buildMemoryContext() {
  let context = [];
  let style = await xP2();
  
  if (style && style.id !== "default") {
    context.push({
      type: "system",
      content: `Output style: ${style.displayName} is active`
    });
  }
  
  return context;
}
#+end_src

* Agent Integration

** Output Style Setup Agent

A dedicated agent type exists for creating custom styles:

- Agent Type: =output-style-setup=
- Purpose: Guide users through style creation
- Capabilities: Read, Write, Edit, Glob, LS, Grep
- Output: Generates markdown files with proper frontmatter

* Best Practices

** Creating Custom Styles

1. **Clear Instructions**: Be specific about desired behavior
2. **Maintain Safety**: Don't override safety guidelines
3. **Test Thoroughly**: Verify style works as expected
4. **Document Well**: Include examples in the style definition
5. **Version Control**: Track project styles in git

** Style Design Principles

1. **Additive Only**: Styles should add instructions, not remove
2. **Preserve Core Function**: Don't break essential features
3. **User-Centric**: Focus on improving user experience
4. **Consistency**: Maintain consistent tone throughout

* Security Considerations

1. **Prompt Injection**: Styles are appended, not prepended, preventing override of core instructions
2. **Validation**: All custom styles are validated before loading
3. **Scope Isolation**: Project styles don't affect other projects
4. **No Code Execution**: Styles are pure text, no executable code

* Performance Characteristics

- Styles are cached after first load (=YA= wrapper)
- File system operations are minimized
- Frontmatter parsing is optimized
- Style switching is instantaneous

* Limitations

1. **No Dynamic Styles**: Styles cannot change during conversation
2. **Text Only**: No support for structured data or code
3. **Single Style Active**: Cannot combine multiple styles
4. **No Conditional Logic**: Styles are static text

* Future Considerations

The =isCodingRelated= flag (lines 364683, 364696) suggests planned features:

1. Non-coding style categories
2. Context-aware style selection
3. Style composition/inheritance
4. Dynamic style parameters
5. Style marketplace integration

* Code Reference

| Function | Line | Purpose |
|----------|------|---------|
| =Eu= | 364771 | Load all available styles |
| =xP2= | 364788 | Get current active style |
| =JL5= | 364806 | Case-insensitive style lookup |
| =ko= | 364745 | Extract description from content |
| =sR2= | 364794 | Get style ID from settings |
| =jZ= | 364752 | Discover style files |
| =showStyleMenu= | 424934 | Display interactive menu |
| =setStyle= | 424967 | Change active style |

* Conclusion

Claude Code v1.0.90's output style system represents a sophisticated prompt engineering framework that democratizes AI behavior customization. By providing both built-in styles and a flexible custom style system, it enables users to tailor Claude's communication to their specific needs while maintaining safety and functionality. The implementation demonstrates excellent software design principles including separation of concerns, extensibility, and graceful degradation.